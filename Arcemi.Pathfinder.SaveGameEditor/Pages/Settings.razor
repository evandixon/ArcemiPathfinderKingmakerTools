@page "/Settings"
@inject SettingsViewModel Model
@inject StateManager State

<fieldset class="form-controller" disabled="@State.IsBusy">

<div>
    <p class="alert alert-info">Changing the settings will take effect immediately.</p>
</div>
<hr />

<div class="row g-3">
    <div class="col-md-12">
        <h3>File System</h3>
    </div>
</div>
<div class="row g-3">
    <div class="col-md-12">
        <label class="form-label">App Data Folder</label>
        <div class="input-group mb-3">
            <div class="btn @(IsValidAppDataFolder ? "btn-success": "btn-default")">
                <span class="oi @(IsValidAppDataFolder ? "oi-thumb-up" : "oi-thumb-down")"></span>
            </div>
            <input class="form-control" type="text" @bind="AppDataFolder" />
            <button class="btn btn-info" @onclick="SelectAppDataFolder">...</button>
        </div>
        <p>The path to the application data folder. There should be 2 folders inside ("Saved Games" and "Portraits").</p>
    </div>
</div>
<div class="row g-3">
    <div class="col-md-12">
        <label class="form-label">Game Folder</label>
        <div class="input-group">
            <div class="btn @(IsValidGameFolder ? "btn-success": "btn-default")">
                <span class="oi @(IsValidGameFolder ? "oi-thumb-up" : "oi-thumb-down")"></span>
            </div>
            <input class="form-control" type="text" @bind="GameFolder" />
            <button class="btn btn-info" @onclick="SelectGameFolder">...</button>
        </div>
        <p>The path to the game folder where the game is installed.
            Setting this will enable the editor to access game resources directly.
            It's used to look up names of items and more.
        </p>
    </div>
</div>

@if (!string.IsNullOrEmpty(_saveMessage)) {
    <div>
        <p class="alert alert-warning">@_saveMessage</p>
    </div>
}

</fieldset>

@code {

    protected string AppDataFolder
    {
        get => Model.Config.AppDataFolder;
        set {
            Model.Config.AppDataFolder = value;
            Save();
        }
    }

    protected string GameFolder
    {
        get => Model.Config.GameFolder;
        set {
            Model.Config.GameFolder = value;
            Save();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await State.ExecuteAsync(async () => {
            await Model.InitializeAsync();
        });
    }

    async Task SelectAppDataFolder()
    {
        await State.ExecuteAsync(async () => {
            var window = ElectronNET.API.Electron.WindowManager.BrowserWindows.First();
            var options = new ElectronNET.API.Entities.OpenDialogOptions {
                Title = "Select the app data folder",
                Properties = new[] { ElectronNET.API.Entities.OpenDialogProperty.openDirectory},
                DefaultPath = AppDataFolder
            };
            var files = await ElectronNET.API.Electron.Dialog.ShowOpenDialogAsync(window, options);
            var file = files?.FirstOrDefault();
            if (!string.IsNullOrEmpty(file)) {
                AppDataFolder = file;
            }
        });
    }

    async Task SelectGameFolder()
    {
        await State.ExecuteAsync(async () => {
            var window = ElectronNET.API.Electron.WindowManager.BrowserWindows.First();
            var options = new ElectronNET.API.Entities.OpenDialogOptions {
                Title = "Select the game folder",
                Properties = new[] { ElectronNET.API.Entities.OpenDialogProperty.openDirectory},
                DefaultPath = GameFolder
            };
            var files = await ElectronNET.API.Electron.Dialog.ShowOpenDialogAsync(window, options);
            var file = files?.FirstOrDefault();
            if (!string.IsNullOrEmpty(file)) {
                GameFolder = file;
            }
        });
    }

    private bool IsValidGameFolder => Model.ValidateGameFolder();
    private bool IsValidAppDataFolder => Model.ValidateAppDataFolder();

    private string _saveMessage;
    private int _saveMarker;
    private int _isSaving;
    private void Save()
    {
        System.Threading.Interlocked.Increment(ref _saveMarker);
        var s = System.Threading.Interlocked.CompareExchange(ref _isSaving, 1, 0);
        if (s == 1) return; // Already saving
        _saveMessage = null;

        Task.Factory.StartNew(async () => {
            while (_saveMarker > 0) {
                System.Threading.Interlocked.Exchange(ref _saveMarker, 0);
                try {
                    await Model.SaveConfigAsync();
                }
                catch (Exception ex) {
                    _saveMessage = "Error when saving: " + ex.Message;
                }
            }
            System.Threading.Interlocked.Exchange(ref _isSaving, 0);
        });
    }
}
